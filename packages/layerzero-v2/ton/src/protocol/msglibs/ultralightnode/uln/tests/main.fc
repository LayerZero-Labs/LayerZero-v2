#include "testutil.fc";

#include "../handler.fc";
#include "../interface.fc";
#include "../storage.fc";

#include "../../msgdata/Attestation.fc";
#include "../../msgdata/InitUln.fc";
#include "../../msgdata/RentRefill.fc";
#include "../../msgdata/TreasuryFeeBps.fc";
#include "../../msgdata/UlnReceiveConfig.fc";
#include "../../msgdata/UlnSendConfig.fc";
#include "../../msgdata/UlnWorkerFeelibInfo.fc";
#include "../../ulnConnection/interface.fc";
#include "../../ulnManager/interface.fc";

#include "../../../../interfaces.fc";

#include "../../../../../classes/msgdata/MdAddress.fc";
#include "../../../../../classes/msgdata/MdObj.fc";

#include "../../../../../funC++/actions/utils.fc";
#include "../../../../../funC++/classlib.fc";
#include "../../../../../funC++/constants.fc";
#include "../../../../../funC++/testutils.fc";
#include "../../../../../funC++/utils.fc";

#include "../../../../../../tests/baseContractTest.fc";
#include "../../../../../../tests/consts.fc";
#include "../../../../../../tests/mocks.fc";
#include "../../../../../../tests/protocolStorageTestUtils.fc";
#include "../../../../../../tests/testMain.fc";

slice _testName() { return "uln"; }

() _createInitializedStorage() impure {
    initialize(
        md::InitUln::New(
            MOCK_ULN_CONNECTION_CODE(),
            TREASURY_FEE_BPS
        )
    );
}

cell createContractStorage() impure {
    cell $obj = Uln::New(getCaller(), SRC_EID, DST_EID);
    setContractStorage($obj);
    return $obj;
}

int _callCheckPermissions(int op, cell $md) impure {
    checkPermissions(op, $md);
    return 0;
}

;;; ===============================TESTS=========================================

(int, slice) ulnCommitPacket::success::basic(cell $storage) impure {
    return test::handler::shouldPass(
        ulnCommitPacket,
        md::MdAddress::New(
            MOCK_RECEIVE_PACKET(),
            ULN_CONNECTION_ADDRESS
        ),
        unsafeTuple([
            0,
            _newAction<call>(
                ULN_CONNECTION_ADDRESS,
                UlnConnection::OP::ULN_CONNECTION_COMMIT_PACKET,
                md::MdObj::New(
                    MOCK_RECEIVE_PACKET(),
                    $storage.cl::get<objRef>(Uln::defaultUlnReceiveConfig)
                )
            )
        ]),
        $storage,
        txnContext
    );
}

(int, slice) ulnVerify::success::basic(cell $storage) impure {
    cell $attestation = lz::Attestation::New(
        PACKET_HASH, DEFAULT_CONFIRMATIONS
    );
    spoofCaller(MOCK_DEFAULT_REQUIRED_DVN_ADDRESS(0));
    return test::handler::shouldPass(
        ulnVerify,
        md::MdAddress::New(
            $attestation,
            ULN_CONNECTION_ADDRESS
        ),
        unsafeTuple([
            0,
            _newAction<call>(
                ULN_CONNECTION_ADDRESS,
                UlnConnection::OP::ULN_CONNECTION_VERIFY,
                md::ExtendedMd::New(
                    $attestation,
                    $storage.cl::get<objRef>(Uln::defaultUlnReceiveConfig),
                    MOCK_DEFAULT_REQUIRED_DVN_ADDRESS(0)
                )
            )
        ]),
        $storage,
        txnContext
    );
}

(int, slice) garbageCollectInvalidAttestations::success::basic(cell $storage) {
    cell $mdAddress = md::MdAddress::New(MOCK_DEFAULT_ULN_RECEIVE_CONFIG(), ULN_CONNECTION_ADDRESS);

    return test::handler::shouldPass(
        garbageCollectInvalidAttestations,
        $mdAddress,
        unsafeTuple([
            0,
            _newAction<call>(
                ULN_CONNECTION_ADDRESS,
                UlnConnection::OP::GARBAGE_COLLECT_INVALID_ATTESTATIONS,
                md::MdObj::New(
                    $mdAddress.cl::get<objRef>(md::MdAddress::md),
                    $storage.cl::get<objRef>(Uln::defaultUlnReceiveConfig)
                )
            )
        ]),
        $storage,
        txnContext
    );
}

(int, slice) collectWorkerRent::success::basic(cell $storage) impure {
    ;; add worker with sufficient rent for 30 days
    cell $workerFeelibInfo = MOCK_ULN_WORKER_FEELIB_INFO(MOCK_DEFAULT_REQUIRED_DVN_ADDRESS(0), Uln::CONST::INITIAL_RENT_NANOS);
    updateWorkerFeelib($workerFeelibInfo);
    $storage = getContractStorage();

    ;; advance 15 days
    int fifteenDaysSeconds = 15 * 24 * 60 * 60;
    setNewTime(now() + fifteenDaysSeconds);

    ;; build $expectedWorkerInfo and $expectedStorage
    int rentOwed = Uln::CONST::RENT_NANOS_PER_SECOND * fifteenDaysSeconds;
    int currentRent = $workerFeelibInfo.cl::get<coins>(UlnWorkerFeelibInfo::rentBalance);
    int expectedRent = currentRent - rentOwed;

    cell $expectedWorkerInfo = $workerFeelibInfo
        .cl::set(UlnWorkerFeelibInfo::rentBalance, expectedRent)
        .cl::set(UlnWorkerFeelibInfo::lastRentTimestamp, now());

    cell $expectedStorage = $storage
        .cl::nestedDict256::setRef(
            Uln::workerFeelibInfos,
            $workerFeelibInfo.cl::get<address>(UlnWorkerFeelibInfo::workerAddress),
            $expectedWorkerInfo
        );

    return test::handler::shouldPass(
        collectWorkerRent,
        $workerFeelibInfo,
        unsafeTuple([
            0,
            _newAction<event>(
                Uln::event::ULN_COLLECT_WORKER_RENT,
                $expectedWorkerInfo
            )
        ]),
        $expectedStorage,
        txnContext
    );
}

(int, slice) collectWorkerRent::success::admin(cell $storage) impure {
    ;; add worker with sufficient rent for 30 days
    cell $workerFeelibInfo = MOCK_ADMIN_ULN_WORKER_FEELIB_INFO(
        MOCK_DEFAULT_REQUIRED_DVN_ADDRESS(0)
    );
    updateWorkerFeelib($workerFeelibInfo);
    $storage = getContractStorage();

    ;; advance 15 days
    int fifteenDaysSeconds = 15 * 24 * 60 * 60;
    setNewTime(now() + fifteenDaysSeconds);

    return test::handler::shouldPass(
        collectWorkerRent,
        $workerFeelibInfo,
        emptyActions(),
        $storage,
        txnContext
    );
}

(int, slice) collectWorkerRent::success::evicted::insufficientRent(cell $storage) impure {
    ;; add worker with sufficient rent for 30 days
    cell $workerFeelibInfo = MOCK_ULN_WORKER_FEELIB_INFO(MOCK_DEFAULT_REQUIRED_DVN_ADDRESS(0), Uln::CONST::INITIAL_RENT_NANOS);
    updateWorkerFeelib($workerFeelibInfo);
    $storage = getContractStorage();

    ;; advance 31 days
    int initialTimestamp = now();
    int 31DaysSeconds = 31 * 24 * 60 * 60;
    setNewTime(initialTimestamp + 31DaysSeconds);

    ;; build $expectedWorkerInfo and $expectedStorage from $actualStorage
    cell $actualStorage = getContractStorage();

    (cell $expectedWorkerInfo, _) = $actualStorage.cl::nestedDict256::get<cellRef>(
        Uln::workerFeelibInfos,
        $workerFeelibInfo.cl::get<address>(UlnWorkerFeelibInfo::workerAddress)
    );

    cell $expectedStorage = $actualStorage
        .cl::nestedDict256::delete(
            Uln::workerFeelibInfos,
            $workerFeelibInfo.cl::get<address>(UlnWorkerFeelibInfo::workerAddress)
        )
        .cl::set(Uln::remainingWorkerSlots, Uln::MaxWorkerFeelibs - UlnManager::CONST::MAX_ADMIN_WORKERS)
    ;

    ;; call collectWorkerRent
    return test::handler::shouldPass(
        collectWorkerRent,
        $workerFeelibInfo,
        unsafeTuple([
            0,
            _newAction<event>(
                Uln::event::ULN_WORKER_EVICTED,
                $expectedWorkerInfo
            )
        ]),
        $expectedStorage,
        txnContext
    );
}

(int, slice) collectWorkerRent::revert::nonexistentWorker(cell $storage) impure {
    cell $workerFeelibInfo = MOCK_ULN_WORKER_FEELIB_INFO(MOCK_DEFAULT_REQUIRED_DVN_ADDRESS(0), Uln::CONST::INITIAL_RENT_NANOS);

    return test::handler::shouldFail(
        collectWorkerRent,
        $workerFeelibInfo,
        Uln::ERROR::nonexistentWorker
    );
}

(int, slice) refillWorkerRent::success::basic(cell $storage) impure {
    cell $workerFeelibInfo = MOCK_ULN_WORKER_FEELIB_INFO(MOCK_DEFAULT_REQUIRED_DVN_ADDRESS(0), Uln::CONST::INITIAL_RENT_NANOS * 2);
    updateWorkerFeelib($workerFeelibInfo);
    cell $expectedStorage = getContractStorage();
    setContractStorage($storage);

    cell $workerFeelibInfo = MOCK_ULN_WORKER_FEELIB_INFO(MOCK_DEFAULT_REQUIRED_DVN_ADDRESS(0), Uln::CONST::INITIAL_RENT_NANOS);
    updateWorkerFeelib($workerFeelibInfo);

    cell $rentRefill = md::RentRefill::New(
        MOCK_DEFAULT_REQUIRED_DVN_ADDRESS(0),
        Uln::CONST::INITIAL_RENT_NANOS
    );

    return test::handler::shouldPass(
        refillWorkerRent,
        $rentRefill,
        unsafeTuple([
            0,
            _newAction<payment>(
                getOwner(),
                Uln::CONST::INITIAL_RENT_NANOS,
                0
            ),
            _newAction<event>(
                Uln::event::ULN_WORKER_RENT_REFILLED,
                $rentRefill
            )
        ]),
        $expectedStorage,
        txnContext
    );
}

(int, slice) refillWorkerRent::revert::nonexistentWorker(cell $storage) impure {
    cell $rentRefill = md::RentRefill::New(
        MOCK_DEFAULT_REQUIRED_DVN_ADDRESS(0),
        Uln::CONST::INITIAL_RENT_NANOS
    );

    return test::handler::shouldFail(
        refillWorkerRent,
        $rentRefill,
        Uln::ERROR::nonexistentWorker
    );
}

(int, slice) updateWorkerFeelib::success::basic(cell $storage) impure {
    cell $workerFeelibInfo = MOCK_ULN_WORKER_FEELIB_INFO(MOCK_DEFAULT_REQUIRED_DVN_ADDRESS(0), Uln::CONST::INITIAL_RENT_NANOS);

    return test::handler::shouldPass(
        updateWorkerFeelib,
        $workerFeelibInfo,
        unsafeTuple([
            0,
            _newAction<payment>(
                getOwner(),
                Uln::CONST::INITIAL_RENT_NANOS,
                0
            ),
            _newAction<event>(
                Uln::event::ULN_WORKER_REGISTERED,
                $workerFeelibInfo.cl::set(
                    UlnWorkerFeelibInfo::lastRentTimestamp,
                    now()
                )
            )
        ]),
        $storage
            .cl::nestedDict256::setRef(
                Uln::workerFeelibInfos,
                $workerFeelibInfo.cl::get<address>(UlnWorkerFeelibInfo::workerAddress),
                $workerFeelibInfo.cl::set(
                    UlnWorkerFeelibInfo::lastRentTimestamp,
                    now()
                )
            )
            .cl::set(
                Uln::remainingWorkerSlots,
                Uln::MaxWorkerFeelibs - UlnManager::CONST::MAX_ADMIN_WORKERS - 1
            ),
        txnContext
    );
}

(int, slice) updateWorkerFeelib::success::ignoreRentIfExists(cell $storage) impure {
    ;; Test that if a worker cannot change their rent balance when updating an existing worker
    cell $workerFeelibInfo = MOCK_ULN_WORKER_FEELIB_INFO(
        MOCK_DEFAULT_REQUIRED_DVN_ADDRESS(0),
        Uln::CONST::INITIAL_RENT_NANOS
    );
    updateWorkerFeelib($workerFeelibInfo);
    cell $expectedStorage = getContractStorage();

    return test::handler::shouldPass(
        updateWorkerFeelib,
        $workerFeelibInfo.cl::set(UlnWorkerFeelibInfo::rentBalance, MAX_U128),
        unsafeTuple([
            0,
            _newAction<event>(
                Uln::event::ULN_WORKER_REGISTERED,
                $workerFeelibInfo.cl::set(UlnWorkerFeelibInfo::lastRentTimestamp, now())
            )
        ]),
        $expectedStorage,
        txnContext
    );
}


(int, slice) updateWorkerFeelib::success::admin(cell $storage) impure {
    cell $workerFeelibInfo = MOCK_ADMIN_ULN_WORKER_FEELIB_INFO(
        MOCK_DEFAULT_REQUIRED_DVN_ADDRESS(0)
    );

    return test::handler::shouldPass(
        updateWorkerFeelib,
        $workerFeelibInfo,
        unsafeTuple([
            0,
            _newAction<event>(
                Uln::event::ULN_WORKER_REGISTERED,
                $workerFeelibInfo.cl::set(
                    UlnWorkerFeelibInfo::lastRentTimestamp,
                    now()
                )
            )
        ]),
        $storage
            .cl::nestedDict256::setRef(
                Uln::workerFeelibInfos,
                $workerFeelibInfo.cl::get<address>(UlnWorkerFeelibInfo::workerAddress),
                $workerFeelibInfo.cl::set(
                    UlnWorkerFeelibInfo::lastRentTimestamp,
                    now()
                )
            )
            .cl::set(Uln::remainingAdminWorkerSlots, UlnManager::CONST::MAX_ADMIN_WORKERS - 1),
        txnContext
    );
}

(int, slice) updateWorkerFeelib::fail::insufficientRent(cell $storage) impure {
    cell $workerFeelibInfo = MOCK_ULN_WORKER_FEELIB_INFO(MOCK_DEFAULT_REQUIRED_DVN_ADDRESS(0), Uln::CONST::INITIAL_RENT_NANOS - 1);

    return test::handler::shouldFail(
        updateWorkerFeelib,
        $workerFeelibInfo,
        Uln::ERROR::insufficientRent
    );
}

(int, slice) updateWorkerFeelib::fail::storageTooLarge(cell $storage) impure {
    cell $workerFeelibInfo = UlnWorkerFeelibInfo::New(
        MOCK_DEFAULT_REQUIRED_DVN_ADDRESS(0),
        my_code(),
        my_code(),
        NULLADDRESS,
        DST_EID,
        Uln::CONST::INITIAL_RENT_NANOS,
        false
    );

    return test::handler::shouldFail(
        updateWorkerFeelib,
        $workerFeelibInfo,
        Uln::ERROR::invalidWorkerStorage
    );
}


(int, slice) updateWorkerFeelib::success::workerAlreadyExists(cell $storage) impure {
    cell $oldWorkerFeelibInfo = MOCK_ULN_WORKER_FEELIB_INFO(MOCK_DEFAULT_REQUIRED_DVN_ADDRESS(0), Uln::CONST::INITIAL_RENT_NANOS);
    updateWorkerFeelib($oldWorkerFeelibInfo);

    cell $newWorkerFeelibInfo = MOCK_ULN_WORKER_FEELIB_INFO_WITH_FRIEND(
        MOCK_DEFAULT_REQUIRED_DVN_ADDRESS(0),
        MOCK_DEFAULT_OPTIONAL_DVN_ADDRESS(0),
        Uln::CONST::INITIAL_RENT_NANOS
    );

    (cell $registeredWorkerInfo, _) = getContractStorage()
        .cl::nestedDict256::get<cellRef>(
            Uln::workerFeelibInfos,
            MOCK_DEFAULT_REQUIRED_DVN_ADDRESS(0)
        );
    return test::handler::shouldPass(
        updateWorkerFeelib,
        $newWorkerFeelibInfo,
        unsafeTuple([
            0,
            _newAction<event>(
                Uln::event::ULN_WORKER_REGISTERED,
                $registeredWorkerInfo.cl::set(
                    UlnWorkerFeelibInfo::friendWorkerAddress,
                    MOCK_DEFAULT_OPTIONAL_DVN_ADDRESS(0)
                )
            )
        ]),
        getContractStorage()
            .cl::nestedDict256::setRef(
                Uln::workerFeelibInfos,
                MOCK_DEFAULT_REQUIRED_DVN_ADDRESS(0),
                $registeredWorkerInfo.cl::set(
                    UlnWorkerFeelibInfo::friendWorkerAddress,
                    MOCK_DEFAULT_OPTIONAL_DVN_ADDRESS(0)
                )
            ),
        txnContext
    );
}

(int, slice) updateWorkerFeelib::success::UpdateEvenWhenWorkerSlotsFull(cell $storage) impure {
    setContractStorage(
        $storage.cl::set(Uln::remainingWorkerSlots, 1)
    );
    cell $oldWorkerFeelibInfo = MOCK_ULN_WORKER_FEELIB_INFO(MOCK_DEFAULT_REQUIRED_DVN_ADDRESS(0), Uln::CONST::INITIAL_RENT_NANOS);
    updateWorkerFeelib($oldWorkerFeelibInfo);

    cell $newWorkerFeelibInfo = MOCK_ULN_WORKER_FEELIB_INFO_WITH_FRIEND(
        MOCK_DEFAULT_REQUIRED_DVN_ADDRESS(0),
        MOCK_DEFAULT_OPTIONAL_DVN_ADDRESS(0),
        Uln::CONST::INITIAL_RENT_NANOS
    );

    (cell $registeredWorkerFeelibInfo, _) = getContractStorage().cl::nestedDict256::get<cellRef>(
        Uln::workerFeelibInfos,
        MOCK_DEFAULT_REQUIRED_DVN_ADDRESS(0)
    );

    return test::handler::shouldPass(
        updateWorkerFeelib,
        $newWorkerFeelibInfo,
        unsafeTuple([
            0,
            _newAction<event>(
                Uln::event::ULN_WORKER_REGISTERED,
                $registeredWorkerFeelibInfo.cl::set(
                    UlnWorkerFeelibInfo::friendWorkerAddress,
                    MOCK_DEFAULT_OPTIONAL_DVN_ADDRESS(0)
                )
            )
        ]),
        getContractStorage()
            .cl::nestedDict256::setRef(
                Uln::workerFeelibInfos,
                MOCK_DEFAULT_REQUIRED_DVN_ADDRESS(0),
                $registeredWorkerFeelibInfo.cl::set(
                    UlnWorkerFeelibInfo::friendWorkerAddress,
                    MOCK_DEFAULT_OPTIONAL_DVN_ADDRESS(0)
                )
            ),
        txnContext
    );
}

(int, slice) updateWorkerFeelib::success::CantAddWorkerWhenSlotsFull(cell $storage) impure {
    setContractStorage(
        $storage.cl::set(Uln::remainingWorkerSlots, 1)
    );
    cell $oldWorkerFeelibInfo = MOCK_ULN_WORKER_FEELIB_INFO(MOCK_DEFAULT_REQUIRED_DVN_ADDRESS(0), Uln::CONST::INITIAL_RENT_NANOS);
    updateWorkerFeelib($oldWorkerFeelibInfo);

    cell $newWorkerFeelibInfo = MOCK_ULN_WORKER_FEELIB_INFO(MOCK_DEFAULT_OPTIONAL_DVN_ADDRESS(0), Uln::CONST::INITIAL_RENT_NANOS);

    return test::handler::shouldPass(
        updateWorkerFeelib,
        $newWorkerFeelibInfo,
        unsafeTuple([
            0,
            _newAction<event>(
                Uln::event::ULN_WORKER_SLOTS_FULL,
                $newWorkerFeelibInfo
            )
        ]),
        getContractStorage(),
        txnContext
    );
}

(int, slice) deregisterWorkerFeelib::success::basic(cell $storage) impure {
    cell $workerFeelibInfo = MOCK_ULN_WORKER_FEELIB_INFO(
        MOCK_DEFAULT_REQUIRED_DVN_ADDRESS(0),
        Uln::CONST::INITIAL_RENT_NANOS
    );
    updateWorkerFeelib($workerFeelibInfo);
    $storage = getContractStorage();

    (cell $workerFeelibInfo, _) = $storage
        .cl::nestedDict256::get<cellRef>(
            Uln::workerFeelibInfos,
            MOCK_DEFAULT_REQUIRED_DVN_ADDRESS(0)
        );

    spoofCaller(MOCK_DEFAULT_REQUIRED_DVN_ADDRESS(0));
    return test::handler::shouldPass(
        deregisterWorkerFeelib,
        cl::nullObject(),
        unsafeTuple([
            0,
            _newAction<event>(
                Uln::event::ULN_WORKER_DEREGISTERED,
                $workerFeelibInfo
            )
        ]),
        $storage
            .cl::nestedDict256::delete(
                Uln::workerFeelibInfos,
                MOCK_DEFAULT_REQUIRED_DVN_ADDRESS(0)
            )
            .cl::set(
                Uln::remainingWorkerSlots,
                $storage.cl::get<uint16>(Uln::remainingWorkerSlots) + 1
            )
        ,
        txnContext
    );
}

(int, slice) deregisterWorkerFeelib::success::admin(cell $storage) impure {
    cell $workerFeelibInfo = MOCK_ADMIN_ULN_WORKER_FEELIB_INFO(
        MOCK_DEFAULT_REQUIRED_DVN_ADDRESS(0)
    );
    updateWorkerFeelib($workerFeelibInfo);
    $storage = getContractStorage();

    (cell $workerFeelibInfo, _) = $storage
        .cl::nestedDict256::get<cellRef>(
            Uln::workerFeelibInfos,
            MOCK_DEFAULT_REQUIRED_DVN_ADDRESS(0)
        );

    spoofCaller(MOCK_DEFAULT_REQUIRED_DVN_ADDRESS(0));
    return test::handler::shouldPass(
        deregisterWorkerFeelib,
        cl::nullObject(),
        unsafeTuple([
            0,
            _newAction<event>(
                Uln::event::ULN_WORKER_DEREGISTERED,
                $workerFeelibInfo
            )
        ]),
        $storage
            .cl::nestedDict256::delete(
                Uln::workerFeelibInfos,
                MOCK_DEFAULT_REQUIRED_DVN_ADDRESS(0)
            )
            .cl::set(
                Uln::remainingAdminWorkerSlots,
                $storage.cl::get<uint16>(Uln::remainingAdminWorkerSlots) + 1
            )
        ,
        txnContext
    );
}

(int, slice) deregisterWorkerFeelib::success::nonexistentWorker(cell $storage) impure {
    cell $workerFeelibInfo = MOCK_ULN_WORKER_FEELIB_INFO(
        MOCK_DEFAULT_REQUIRED_DVN_ADDRESS(0),
        Uln::CONST::INITIAL_RENT_NANOS
    );

    updateWorkerFeelib($workerFeelibInfo);
    cell expectedStorage = getContractStorage();

    spoofCaller(ARBITRARY_ADDRESS);
    return test::handler::shouldPass(
        deregisterWorkerFeelib,
        cl::nullObject(),
        unsafeTuple([
            0
        ]),
        expectedStorage,
        txnContext
    );
}

(int, slice) setDefaultUlnSendConfig::success::basic(cell $storage) impure {
    cell $ulnSendConfig = MOCK_DEFAULT_ULN_SEND_CONFIG();
    return test::handler::shouldPass(
        setDefaultUlnSendConfig,
        $ulnSendConfig,
        unsafeTuple([
            0,
            _newAction<event>(
                Uln::event::ULN_DEFAULT_SEND_CONFIG_SET,
                $ulnSendConfig
            )
        ]),
        $storage.cl::set(Uln::defaultUlnSendConfig, $ulnSendConfig),
        txnContext
    );
}

(int, slice) setDefaultUlnSendConfig::success::malicious(cell $storage) impure {
    cell $ulnSendConfig = MOCK_DEFAULT_ULN_SEND_CONFIG();
    cell $maliciousUlnSendConfig = _dupWithGarbage($ulnSendConfig);
    return test::handler::shouldPass(
        setDefaultUlnSendConfig,
        $maliciousUlnSendConfig,
        unsafeTuple([
            0,
            _newAction<event>(
                Uln::event::ULN_DEFAULT_SEND_CONFIG_SET,
                $ulnSendConfig
            )
        ]),
        $storage.cl::set(Uln::defaultUlnSendConfig, $ulnSendConfig),
        txnContext
    );
}
(int, slice) setDefaultUlnSendConfig::fail::nullAddress::dvnConfigError(cell $storage) impure {
    cell $ulnSendConfig = UlnSendConfig::New(
        DEFAULT_WORKER_QUOTE_GAS_LIMIT,
        DEFAULT_MAX_MESSAGE_BYTES,
        true,
        DEFAULT_EXECUTOR,
        true,
        MOCK_DVN_CELL_WITH_NULL(2),
        true,
        MOCK_DEFAULT_OPTIONAL_DVN_CELL(2, true),
        true,
        DEFAULT_CONFIRMATIONS
    );

    return test::handler::shouldFail(
        setDefaultUlnSendConfig,
        $ulnSendConfig,
        UlnSendConfig::ERROR::DVN_CONFIG_ERROR
    );
}

(int, slice) setDefaultUlnSendConfig::fail::maxDVNCount::dvnConfigError(cell $storage) impure {
    cell $ulnSendConfig = UlnSendConfig::New(
        DEFAULT_WORKER_QUOTE_GAS_LIMIT,
        DEFAULT_MAX_MESSAGE_BYTES,
        true,
        DEFAULT_EXECUTOR,
        true,
        MOCK_DEFAULT_REQUIRED_DVN_CELL(256, MOCK_DEFAULT_REQUIRED_DVN_ADDRESS(0)),
        true,
        MOCK_DEFAULT_OPTIONAL_DVN_CELL(3, 2),
        true,
        DEFAULT_CONFIRMATIONS
    );

    return test::handler::shouldFail(
        setDefaultUlnSendConfig,
        $ulnSendConfig,
        UlnSendConfig::ERROR::DVN_CONFIG_ERROR
    );
}

(int, slice) setDefaultUlnSendConfig::fail::tooManyRefs::dvnConfigError(cell $storage) impure {
    cell $ulnSendConfig = UlnSendConfig::New(
        DEFAULT_WORKER_QUOTE_GAS_LIMIT,
        DEFAULT_MAX_MESSAGE_BYTES,
        true,
        DEFAULT_EXECUTOR,
        true,
        MOCK_DVN_LIST_WITH_REF(2),
        true,
        MOCK_DEFAULT_OPTIONAL_DVN_CELL(2, 3),
        true,
        DEFAULT_CONFIRMATIONS
    );

    return test::handler::shouldFail(
        setDefaultUlnSendConfig,
        $ulnSendConfig,
        UlnSendConfig::ERROR::DVN_CONFIG_ERROR
    );
}

(int, slice) setDefaultUlnReceiveConfig::success::basic(cell $storage) impure {
    cell $ulnReceiveConfig = MOCK_DEFAULT_ULN_RECEIVE_CONFIG();
    return test::handler::shouldPass(
        setDefaultUlnReceiveConfig,
        $ulnReceiveConfig,
        unsafeTuple([
            0,
            _newAction<event>(
                Uln::event::ULN_DEFAULT_RECEIVE_CONFIG_SET,
                $ulnReceiveConfig
            )
        ]),
        $storage.cl::set(Uln::defaultUlnReceiveConfig, $ulnReceiveConfig),
        txnContext
    );
}

(int, slice) setDefaultUlnReceiveConfig::success::maxRequiredDVNs(cell $storage) impure {
    cell $ulnReceiveConfig = UlnReceiveConfig::New(
        false,
        DEFAULT_MIN_COMMIT_PACKET_GAS,
        false,
        CUSTOM_CONFIRMATIONS,
        false,
        _buildReceiveDvnList(UlnReceiveConfig::MaxRequiredDVNs, MOCK_CUSTOM_REQUIRED_DVN_ADDRESS(0)),
        false,
        _buildReceiveDvnList(0, MOCK_CUSTOM_OPTIONAL_DVN_ADDRESS(0)),
        0
    );

    return test::handler::shouldPass(
        setDefaultUlnReceiveConfig,
        $ulnReceiveConfig,
        unsafeTuple([
            0,
            _newAction<event>(
                Uln::event::ULN_DEFAULT_RECEIVE_CONFIG_SET,
                $ulnReceiveConfig
            )
        ]),
        $storage.cl::set(Uln::defaultUlnReceiveConfig, $ulnReceiveConfig),
        txnContext
    );
}

(int, slice) setDefaultUlnReceiveConfig::success::maxOptionalDVNs(cell $storage) impure {
    cell $ulnReceiveConfig = UlnReceiveConfig::New(
        false,
        DEFAULT_MIN_COMMIT_PACKET_GAS,
        false,
        CUSTOM_CONFIRMATIONS,
        false,
        _buildReceiveDvnList(0, MOCK_CUSTOM_REQUIRED_DVN_ADDRESS(0)),
        false,
        _buildReceiveDvnList(UlnReceiveConfig::MaxOptionalDVNs, MOCK_CUSTOM_OPTIONAL_DVN_ADDRESS(0)),
        UlnReceiveConfig::MaxOptionalDVNs
    );

    return test::handler::shouldPass(
        setDefaultUlnReceiveConfig,
        $ulnReceiveConfig,
        unsafeTuple([
            0,
            _newAction<event>(
                Uln::event::ULN_DEFAULT_RECEIVE_CONFIG_SET,
                $ulnReceiveConfig
            )
        ]),
        $storage.cl::set(Uln::defaultUlnReceiveConfig, $ulnReceiveConfig),
        txnContext
    );
}

(int, slice) setDefaultUlnReceiveConfig::success::maxDVNs(cell $storage) impure {
    cell $ulnReceiveConfig = UlnReceiveConfig::New(
        false,
        DEFAULT_MIN_COMMIT_PACKET_GAS,
        false,
        CUSTOM_CONFIRMATIONS,
        false,
        _buildReceiveDvnList(UlnReceiveConfig::MaxRequiredDVNs, MOCK_CUSTOM_REQUIRED_DVN_ADDRESS(0)),
        false,
        _buildReceiveDvnList(UlnReceiveConfig::MaxOptionalDVNs, MOCK_CUSTOM_OPTIONAL_DVN_ADDRESS(0)),
        UlnReceiveConfig::MaxOptionalDVNs
    );
    return test::handler::shouldPass(
        setDefaultUlnReceiveConfig,
        $ulnReceiveConfig,
        unsafeTuple([
            0,
            _newAction<event>(
                Uln::event::ULN_DEFAULT_RECEIVE_CONFIG_SET,
                $ulnReceiveConfig
            )
        ]),
        $storage.cl::set(Uln::defaultUlnReceiveConfig, $ulnReceiveConfig),
        txnContext
    );
}

(int, slice) setDefaultUlnReceiveConfig::success::malicious(cell $storage) impure {
    cell $ulnReceiveConfig = MOCK_DEFAULT_ULN_RECEIVE_CONFIG();
    cell $maliciousUlnReceiveConfig = _dupWithGarbage($ulnReceiveConfig);
    return test::handler::shouldPass(
        setDefaultUlnReceiveConfig,
        $maliciousUlnReceiveConfig,
        unsafeTuple([
            0,
            _newAction<event>(
                Uln::event::ULN_DEFAULT_RECEIVE_CONFIG_SET,
                $ulnReceiveConfig
            )
        ]),
        $storage.cl::set(Uln::defaultUlnReceiveConfig, $ulnReceiveConfig),
        txnContext
    );
}

(int, slice) setDefaultUlnReceiveConfig::fail::zeroMinCommitPacketGas(cell $storage) impure {
    cell $ulnReceiveConfig = UlnReceiveConfig::New(
        false,
        0,
        false,
        CUSTOM_CONFIRMATIONS,
        false,
        _buildReceiveDvnList(0, MOCK_CUSTOM_REQUIRED_DVN_ADDRESS(0)),
        false,
        _buildReceiveDvnList(0, MOCK_CUSTOM_OPTIONAL_DVN_ADDRESS(0)),
        0
    );

    return test::handler::shouldFail(
        setDefaultUlnReceiveConfig,
        $ulnReceiveConfig,
        UlnReceiveConfig::ERROR::INVALID_MIN_COMMIT_PACKET_GAS
    );
}

(int, slice) setDefaultUlnReceiveConfig::fail::minCommitPacketGasTooHigh(cell $storage) impure {
    cell $ulnReceiveConfig = UlnReceiveConfig::New(
        false,
        UlnReceiveConfig::MaxCommitPacketValueAssertion() + 1,
        false,
        CUSTOM_CONFIRMATIONS,
        false,
        _buildReceiveDvnList(0, MOCK_CUSTOM_REQUIRED_DVN_ADDRESS(0)),
        false,
        _buildReceiveDvnList(0, MOCK_CUSTOM_OPTIONAL_DVN_ADDRESS(0)),
        0
    );

    return test::handler::shouldFail(
        setDefaultUlnReceiveConfig,
        $ulnReceiveConfig,
        UlnReceiveConfig::ERROR::INVALID_MIN_COMMIT_PACKET_GAS
    );
}

(int, slice) setDefaultUlnReceiveConfig::fail::optionalThresholdTooLarge(cell $storage) impure {
    cell $ulnReceiveConfig = MOCK_CUSTOM_ULN_RECEIVE_CONFIG(1, 1, 2);

    return test::handler::shouldFail(
        setDefaultUlnReceiveConfig,
        $ulnReceiveConfig,
        UlnReceiveConfig::ERROR::OPTIONAL_THRESHOLD_TOO_LARGE
    );
}

(int, slice) setDefaultUlnReceiveConfig::fail::optionalThresholdTooLow(cell $storage) impure {
    cell $ulnReceiveConfig = MOCK_CUSTOM_ULN_RECEIVE_CONFIG(1, 2, 0);

    return test::handler::shouldFail(
        setDefaultUlnReceiveConfig,
        $ulnReceiveConfig,
        UlnReceiveConfig::ERROR::OPTIONAL_THRESHOLD_TOO_LOW
    );
}

(int, slice) setDefaultUlnReceiveConfig::fail::dvnCountsAllNil(cell $storage) impure {
    cell $ulnReceiveConfig = UlnReceiveConfig::New(
        false,
        DEFAULT_MIN_COMMIT_PACKET_GAS,
        false,
        CUSTOM_CONFIRMATIONS,
        false,
        _buildReceiveDvnList(0, MOCK_CUSTOM_REQUIRED_DVN_ADDRESS(0)),
        false,
        _buildReceiveDvnList(0, MOCK_CUSTOM_OPTIONAL_DVN_ADDRESS(0)),
        0
    );

    return test::handler::shouldFail(
        setDefaultUlnReceiveConfig,
        $ulnReceiveConfig,
        UlnReceiveConfig::ERROR::DVN_COUNTS_ALL_NIL
    );
}

(int, slice) setDefaultUlnReceiveConfig::fail::nullRequiredDVN::dvnConfigError(cell $storage) impure {
    cell $ulnReceiveConfig = UlnReceiveConfig::New(
        false,
        DEFAULT_MIN_COMMIT_PACKET_GAS,
        false,
        CUSTOM_CONFIRMATIONS,
        false,
        MOCK_DVN_CELL_WITH_NULL(2),
        false,
        _buildReceiveDvnList(0, MOCK_CUSTOM_OPTIONAL_DVN_ADDRESS(0)),
        0
    );

    return test::handler::shouldFail(
        setDefaultUlnReceiveConfig,
        $ulnReceiveConfig,
        UlnReceiveConfig::ERROR::DVN_CONFIG_ERROR
    );
}

(int, slice) setDefaultUlnReceiveConfig::fail::nullOptionalDVN::dvnConfigError(cell $storage) impure {
    cell $ulnReceiveConfig = UlnReceiveConfig::New(
        false,
        DEFAULT_MIN_COMMIT_PACKET_GAS,
        false,
        CUSTOM_CONFIRMATIONS,
        false,
        _buildReceiveDvnList(0, MOCK_CUSTOM_OPTIONAL_DVN_ADDRESS(0)),
        false,
        MOCK_DVN_CELL_WITH_NULL(2),
        0
    );

    return test::handler::shouldFail(
        setDefaultUlnReceiveConfig,
        $ulnReceiveConfig,
        UlnReceiveConfig::ERROR::DVN_CONFIG_ERROR
    );
}

(int, slice) setDefaultUlnReceiveConfig::fail::tooManyRefsRequiredDvns::dvnConfigError(cell $storage) impure {
    cell $ulnReceiveConfig = UlnReceiveConfig::New(
        false,
        DEFAULT_MIN_COMMIT_PACKET_GAS,
        false,
        CUSTOM_CONFIRMATIONS,
        false,
        MOCK_DVN_LIST_WITH_REF(2),
        false,
        _buildReceiveDvnList(0, MOCK_CUSTOM_OPTIONAL_DVN_ADDRESS(0)),
        0
    );

    return test::handler::shouldFail(
        setDefaultUlnReceiveConfig,
        $ulnReceiveConfig,
        UlnReceiveConfig::ERROR::DVN_CONFIG_ERROR
    );
}

(int, slice) setDefaultUlnReceiveConfig::fail::tooManyRefsOptionalDvns::dvnConfigError(cell $storage) impure {
    cell $ulnReceiveConfig = UlnReceiveConfig::New(
        false,
        DEFAULT_MIN_COMMIT_PACKET_GAS,
        false,
        CUSTOM_CONFIRMATIONS,
        false,
        _buildReceiveDvnList(0, MOCK_CUSTOM_REQUIRED_DVN_ADDRESS(0)),
        false,
        MOCK_DVN_LIST_WITH_REF(2),
        0
    );

    return test::handler::shouldFail(
        setDefaultUlnReceiveConfig,
        $ulnReceiveConfig,
        UlnReceiveConfig::ERROR::DVN_CONFIG_ERROR
    );
}

(int, slice) setDefaultUlnReceiveConfig::fail::maxRequiredDVNCount::dvnConfigError(cell $storage) impure {
    cell $ulnReceiveConfig = UlnReceiveConfig::New(
        false,
        DEFAULT_MIN_COMMIT_PACKET_GAS,
        false,
        CUSTOM_CONFIRMATIONS,
        false,
        _buildReceiveDvnList(UlnReceiveConfig::MaxRequiredDVNs + 1, MOCK_CUSTOM_REQUIRED_DVN_ADDRESS(0)),
        false,
        _buildReceiveDvnList(0, MOCK_CUSTOM_OPTIONAL_DVN_ADDRESS(0)),
        0
    );

    return test::handler::shouldFail(
        setDefaultUlnReceiveConfig,
        $ulnReceiveConfig,
        UlnReceiveConfig::ERROR::DVN_CONFIG_ERROR
    );
}

(int, slice) setDefaultUlnReceiveConfig::fail::maxOptionalDVNCount::dvnConfigError(cell $storage) impure {
    cell $ulnReceiveConfig = UlnReceiveConfig::New(
        false,
        DEFAULT_MIN_COMMIT_PACKET_GAS,
        false,
        CUSTOM_CONFIRMATIONS,
        false,
        _buildReceiveDvnList(1, MOCK_CUSTOM_REQUIRED_DVN_ADDRESS(0)),
        false,
        _buildReceiveDvnList(UlnReceiveConfig::MaxOptionalDVNs + 1, MOCK_CUSTOM_OPTIONAL_DVN_ADDRESS(0)),
        0
    );

    return test::handler::shouldFail(
        setDefaultUlnReceiveConfig,
        $ulnReceiveConfig,
        UlnReceiveConfig::ERROR::DVN_CONFIG_ERROR
    );
}

(int, slice) setTreasuryFeeBps::success::basic(cell $storage) impure {
    int bps = TREASURY_FEE_BPS;
    cell $treasuryFeeBps = md::TreasuryFeeBps::New(bps);
    return test::handler::shouldPass(
        setTreasuryFeeBps,
        $treasuryFeeBps,
        unsafeTuple([
            0,
            _newAction<event>(
                Uln::event::ULN_TREASURY_FEE_BPS_SET,
                $treasuryFeeBps
            )
        ]),
        $storage.cl::set(Uln::treasuryFeeBps, bps),
        txnContext
    );
}

(int, slice) setTreasuryFeeBps::success::maxBps(cell $storage) impure {
    int bps = 10000;
    cell $treasuryFeeBps = md::TreasuryFeeBps::New(bps);
    return test::handler::shouldPass(
        setTreasuryFeeBps,
        $treasuryFeeBps,
        unsafeTuple([
            0,
            _newAction<event>(
                Uln::event::ULN_TREASURY_FEE_BPS_SET,
                $treasuryFeeBps
            )
        ]),
        $storage.cl::set(Uln::treasuryFeeBps, bps),
        txnContext
    );
}

(int, slice) setTreasuryFeeBps::success::minBps(cell $storage) impure {
    int bps = 0;
    cell $treasuryFeeBps = md::TreasuryFeeBps::New(bps);
    return test::handler::shouldPass(
        setTreasuryFeeBps,
        $treasuryFeeBps,
        unsafeTuple([
            0,
            _newAction<event>(
                Uln::event::ULN_TREASURY_FEE_BPS_SET,
                $treasuryFeeBps
            )
        ]),
        $storage.cl::set(Uln::treasuryFeeBps, bps),
        txnContext
    );
}

(int, slice) setTreasuryFeeBps::revert::invalidBps(cell $storage) impure {
    int bps = 10001;
    cell $treasuryFeeBps = md::TreasuryFeeBps::New(bps);
    return test::handler::shouldFail(
        setTreasuryFeeBps,
        $treasuryFeeBps,
        Uln::ERROR::invalidTreasuryFeeBps
    );
}

tuple baseTest::getTests() impure {
    return empty_tuple()
        .tpush([ulnCommitPacket::success::basic, "ulnCommitPacket::success::basic"])
        .tpush([ulnVerify::success::basic, "ulnVerify::success::basic"])
        ;; -- collectWorkerRent handler tests
        .tpush([collectWorkerRent::success::basic, "collectWorkerRent::success::basic"])
        .tpush([collectWorkerRent::success::admin, "collectWorkerRent::success::admin"])
        .tpush([collectWorkerRent::success::evicted::insufficientRent, "collectWorkerRent::success::evicted::insufficientRent"])
        .tpush([collectWorkerRent::revert::nonexistentWorker, "collectWorkerRent::revert::nonexistentWorker"])
        ;; -- refillWorkerRent handler tests
        .tpush([refillWorkerRent::success::basic, "refillWorkerRent::success::basic"])
        .tpush([refillWorkerRent::revert::nonexistentWorker, "refillWorkerRent::revert::nonexistentWorker"])
        ;; -- updateWorkerFeelib handler tests
        .tpush([updateWorkerFeelib::success::basic, "updateWorkerFeelib::success::basic"])
        .tpush([updateWorkerFeelib::success::ignoreRentIfExists, "updateWorkerFeelib::success::ignoreRentIfExists"])
        .tpush([updateWorkerFeelib::success::admin, "updateWorkerFeelib::success::admin"])
        .tpush([updateWorkerFeelib::fail::insufficientRent, "updateWorkerFeelib::fail::insufficientRent"])
        .tpush([updateWorkerFeelib::fail::storageTooLarge, "updateWorkerFeelib::fail::storageTooLarge"])
        .tpush([updateWorkerFeelib::success::workerAlreadyExists, "updateWorkerFeelib::success::workerAlreadyExists"])
        .tpush([updateWorkerFeelib::success::UpdateEvenWhenWorkerSlotsFull, "updateWorkerFeelib::success::UpdateEvenWhenWorkerSlotsFull"])
        .tpush([updateWorkerFeelib::success::CantAddWorkerWhenSlotsFull, "updateWorkerFeelib::success::CantAddWorkerWhenSlotsFull"])
        ;; -- deregisterWorkerFeelib handler tests
        .tpush([deregisterWorkerFeelib::success::basic, "deregisterWorkerFeelib::success::basic"])
        .tpush([deregisterWorkerFeelib::success::admin, "deregisterWorkerFeelib::success::admin"])
        .tpush([deregisterWorkerFeelib::success::nonexistentWorker, "deregisterWorkerFeelib::success::nonexistentWorker"])
        ;; -- setDefaultUlnSendConfig handler tests
        .tpush([setDefaultUlnSendConfig::success::basic, "setDefaultUlnSendConfig::success::basic"])
        .tpush([setDefaultUlnSendConfig::success::malicious, "setDefaultUlnSendConfig::success::malicious"])
        .tpush([setDefaultUlnSendConfig::fail::nullAddress::dvnConfigError, "setDefaultUlnSendConfig::fail::nullAddress::dvnConfigError"])
        .tpush([setDefaultUlnSendConfig::fail::tooManyRefs::dvnConfigError, "setDefaultUlnSendConfig::fail::tooManyRefs::dvnConfigError"])
        .tpush([setDefaultUlnSendConfig::fail::maxDVNCount::dvnConfigError, "setDefaultUlnSendConfig::fail::maxDVNCount::dvnConfigError"])
        ;; -- setDefaultUlnReceiveConfig handler tests
        .tpush([setDefaultUlnReceiveConfig::success::basic, "setDefaultUlnReceiveConfig::success::basic"])
        .tpush([setDefaultUlnReceiveConfig::success::maxRequiredDVNs, "setDefaultUlnReceiveConfig::success::maxRequiredDVNs"])
        .tpush([setDefaultUlnReceiveConfig::success::maxOptionalDVNs, "setDefaultUlnReceiveConfig::success::maxOptionalDVNs"])
        .tpush([setDefaultUlnReceiveConfig::success::maxDVNs, "setDefaultUlnReceiveConfig::success::maxDVNs"])
        .tpush([setDefaultUlnReceiveConfig::success::malicious, "setDefaultUlnReceiveConfig::success::malicious"])
        .tpush([setDefaultUlnReceiveConfig::fail::zeroMinCommitPacketGas, "setDefaultUlnReceiveConfig::fail::zeroMinCommitPacketGas"])
        .tpush([setDefaultUlnReceiveConfig::fail::minCommitPacketGasTooHigh, "setDefaultUlnReceiveConfig::fail::minCommitPacketGasTooHigh"])
        .tpush([setDefaultUlnReceiveConfig::fail::optionalThresholdTooLarge, "setDefaultUlnReceiveConfig::fail::optionalThresholdTooLarge"])
        .tpush([setDefaultUlnReceiveConfig::fail::optionalThresholdTooLow, "setDefaultUlnReceiveConfig::fail::optionalThresholdTooLow"])
        .tpush([setDefaultUlnReceiveConfig::fail::dvnCountsAllNil, "setDefaultUlnReceiveConfig::fail::dvnCountsAllNil"])
        .tpush([setDefaultUlnReceiveConfig::fail::nullRequiredDVN::dvnConfigError, "setDefaultUlnReceiveConfig::fail::nullRequiredDVN::dvnConfigError"])
        .tpush([setDefaultUlnReceiveConfig::fail::nullOptionalDVN::dvnConfigError, "setDefaultUlnReceiveConfig::fail::nullOptionalDVN::dvnConfigError"])
        .tpush([setDefaultUlnReceiveConfig::fail::tooManyRefsRequiredDvns::dvnConfigError, "setDefaultUlnReceiveConfig::fail::tooManyRefsRequiredDvns::dvnConfigError"])
        .tpush([setDefaultUlnReceiveConfig::fail::tooManyRefsOptionalDvns::dvnConfigError, "setDefaultUlnReceiveConfig::fail::tooManyRefsOptionalDvns::dvnConfigError"])
        .tpush([setDefaultUlnReceiveConfig::fail::maxRequiredDVNCount::dvnConfigError, "setDefaultUlnReceiveConfig::fail::maxRequiredDVNCount::dvnConfigError"])
        .tpush([setDefaultUlnReceiveConfig::fail::maxOptionalDVNCount::dvnConfigError, "setDefaultUlnReceiveConfig::fail::maxOptionalDVNCount::dvnConfigError"])
        ;; -- garbageCollectInvalidAttestations handler tests
        .tpush([garbageCollectInvalidAttestations::success::basic, "garbageCollectInvalidAttestations::success::basic"])
        ;; -- setTreasuryFeeBps handler tests
        .tpush([setTreasuryFeeBps::success::basic, "setTreasuryFeeBps::success::basic"])
        .tpush([setTreasuryFeeBps::success::maxBps, "setTreasuryFeeBps::success::maxBps"])
        .tpush([setTreasuryFeeBps::success::minBps, "setTreasuryFeeBps::success::minBps"])
        .tpush([setTreasuryFeeBps::revert::invalidBps, "setTreasuryFeeBps::revert::invalidBps"])
    ;
}