// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

import { Test } from "forge-std/Test.sol";
import { console2 } from "forge-std/console2.sol";

import { EndpointV2 } from "../contracts/EndpointV2.sol";
import { Origin } from "../contracts/interfaces/ILayerZeroEndpointV2.sol";
import { ILayerZeroReceiver } from "../contracts/interfaces/ILayerZeroReceiver.sol";
import { IMessageLib, MessageLibType } from "../contracts/interfaces/IMessageLib.sol";
import { SetConfigParam } from "../contracts/interfaces/IMessageLibManager.sol";
import { Errors } from "../contracts/libs/Errors.sol";
import { AddressCast } from "../contracts/libs/AddressCast.sol";
import { GUID } from "../contracts/libs/GUID.sol";

/**
 * @title Exploit_CoreProtocol
 * @notice Comprehensive exploit attempt suite for LayerZero V2 core protocol
 * @dev Each test attempts to break a specific invariant with documented expected failure
 */
contract Exploit_CoreProtocol is Test {
    using AddressCast for address;

    EndpointV2 public endpoint;

    address public owner;
    address public alice;
    address public bob;
    address public attacker;
    address public receiveLib;
    address public maliciousReceiveLib;

    uint32 public constant LOCAL_EID = 1;
    uint32 public constant REMOTE_EID = 2;

    bytes32 public aliceB32;
    bytes32 public bobB32;

    // Test payloads
    bytes public message1 = "legitimate message";
    bytes public message2 = "malicious message";
    bytes32 public guid1;
    bytes32 public guid2;
    bytes public payload1;
    bytes public payload2;
    bytes32 public payloadHash1;
    bytes32 public payloadHash2;

    function setUp() public {
        owner = address(this);
        alice = makeAddr("alice");
        bob = makeAddr("bob");
        attacker = makeAddr("attacker");

        aliceB32 = alice.toBytes32();
        bobB32 = bob.toBytes32();

        // Deploy endpoint
        endpoint = new EndpointV2(LOCAL_EID, owner);

        // Deploy mock receive libraries
        receiveLib = address(new MockReceiveLib(address(endpoint), LOCAL_EID));
        maliciousReceiveLib = address(new MockReceiveLib(address(endpoint), LOCAL_EID));

        // Register libraries
        endpoint.registerLibrary(receiveLib);
        endpoint.registerLibrary(maliciousReceiveLib);

        // Set default receive library
        endpoint.setDefaultReceiveLibrary(REMOTE_EID, receiveLib, 0);

        // Prepare test data
        guid1 = GUID.generate(1, REMOTE_EID, alice, LOCAL_EID, bobB32);
        guid2 = GUID.generate(1, REMOTE_EID, alice, LOCAL_EID, bobB32);
        payload1 = abi.encodePacked(guid1, message1);
        payload2 = abi.encodePacked(guid2, message2);
        payloadHash1 = keccak256(payload1);
        payloadHash2 = keccak256(payload2);
    }

    // ========== EXPLOIT ATTEMPT 01: Payload Overwrite via Reverify ==========

    /// @notice CRITICAL: Attempt to overwrite payloadHash by reverifying same nonce
    /// @dev EXPECTED: Should FAIL - reverify should not allow payload substitution
    /// @dev ACTUAL: Test will show if _inbound() allows unconditional overwrite
    function test_Exploit01_PayloadOverwriteViaReverify() public {
        console2.log("\n=== EXPLOIT ATTEMPT 01: Payload Overwrite via Reverify ===");

        // Setup: Bob is a receiver OApp
        MockOApp bobOApp = new MockOApp(address(endpoint));
        vm.prank(bob);
        endpoint.setDelegate(address(bobOApp));

        Origin memory origin = Origin({ srcEid: REMOTE_EID, sender: aliceB32, nonce: 1 });

        // Step 1: Legitimate library verifies with payloadHash1
        vm.prank(receiveLib);
        endpoint.verify(origin, address(bobOApp), payloadHash1);

        bytes32 storedHash = endpoint.inboundPayloadHash(address(bobOApp), REMOTE_EID, aliceB32, 1);
        console2.log("After first verify, stored hash:");
        console2.logBytes32(storedHash);
        console2.log("Expected hash (payload1):");
        console2.logBytes32(payloadHash1);
        assertEq(storedHash, payloadHash1, "First verify should set payloadHash1");

        // Step 2: Attacker gets malicious library approved during grace period
        // (Simulating a scenario where both libs are valid)
        vm.prank(bob);
        endpoint.setReceiveLibrary(address(bobOApp), REMOTE_EID, maliciousReceiveLib, 1000);

        // Step 3: Malicious library attempts to reverify with different payload
        // Check if reverify is allowed
        bool canReverify = endpoint.verifiable(origin, address(bobOApp));
        console2.log("Can reverify (nonce <= lazyNonce, hash != EMPTY)?", canReverify);

        if (canReverify) {
            // Attempt the overwrite attack
            vm.prank(maliciousReceiveLib);
            try endpoint.verify(origin, address(bobOApp), payloadHash2) {
                // If this succeeds, check if hash was overwritten
                bytes32 newHash = endpoint.inboundPayloadHash(address(bobOApp), REMOTE_EID, aliceB32, 1);
                console2.log("After reverify, stored hash:");
                console2.logBytes32(newHash);
                console2.log("Attacker's hash (payload2):");
                console2.logBytes32(payloadHash2);

                if (newHash == payloadHash2) {
                    console2.log(">>> CRITICAL VULNERABILITY: Payload hash was overwritten!");
                    console2.log(">>> Attacker can now execute different payload than originally verified");
                    fail("VULNERABILITY CONFIRMED: Reverify allows payload substitution");
                } else {
                    console2.log(">>> SAFE: Payload hash was not overwritten");
                }
            } catch Error(string memory reason) {
                console2.log(">>> Reverify reverted:", reason);
                console2.log(">>> SAFE: Reverify prevented");
            } catch (bytes memory reason) {
                console2.log(">>> Reverify reverted with low-level error");
                console2.log(">>> SAFE: Reverify prevented");
            }
        } else {
            console2.log(">>> SAFE: Reverify not allowed by _verifiable() check");
        }
    }

    // ========== EXPLOIT ATTEMPT 02: Nonce Gap DoS via Nilify ==========

    /// @notice Attempt to permanently DoS a path by creating unbridgeable nonce gap
    /// @dev EXPECTED: nilify should set NIL_PAYLOAD_HASH which _hasPayloadHash treats as present
    /// @dev This allows _clearPayload to advance lazyInboundNonce past nilified nonces
    function test_Exploit02_NonceGapDoS_NilifyRecovery() public {
        console2.log("\n=== EXPLOIT ATTEMPT 02: Nonce Gap DoS via Nilify ===");

        MockOApp bobOApp = new MockOApp(address(endpoint));
        vm.prank(bob);
        endpoint.setDelegate(address(bobOApp));

        // Step 1: Verify nonces 1 and 3, but NOT 2 (create a gap)
        Origin memory origin1 = Origin({ srcEid: REMOTE_EID, sender: aliceB32, nonce: 1 });
        Origin memory origin3 = Origin({ srcEid: REMOTE_EID, sender: aliceB32, nonce: 3 });

        vm.startPrank(receiveLib);
        endpoint.verify(origin1, address(bobOApp), payloadHash1);
        endpoint.verify(origin3, address(bobOApp), payloadHash1);
        vm.stopPrank();

        console2.log("Verified nonces: 1, 3 (gap at 2)");

        // Step 2: Try to execute nonce 3 - should fail due to gap at nonce 2
        bytes memory payload3 = abi.encodePacked(
            GUID.generate(3, REMOTE_EID, alice, LOCAL_EID, bobB32),
            message1
        );

        vm.expectRevert(abi.encodeWithSelector(Errors.LZ_InvalidNonce.selector, uint64(2)));
        endpoint.lzReceive(origin3, address(bobOApp), guid1, message1, "");
        console2.log(">>> Execute nonce 3 reverted with InvalidNonce(2) - gap blocks execution");

        // Step 3: Attempt recovery via nilify nonce 2
        vm.prank(address(bobOApp));
        endpoint.nilify(address(bobOApp), REMOTE_EID, aliceB32, 2, endpoint.EMPTY_PAYLOAD_HASH());

        bytes32 nonce2Hash = endpoint.inboundPayloadHash(address(bobOApp), REMOTE_EID, aliceB32, 2);
        console2.log("After nilify, nonce 2 hash:");
        console2.logBytes32(nonce2Hash);
        console2.log("NIL_PAYLOAD_HASH:");
        console2.logBytes32(endpoint.NIL_PAYLOAD_HASH());

        // Step 4: Try to execute nonce 3 again
        vm.prank(attacker);
        try endpoint.lzReceive(origin3, address(bobOApp), guid1, message1, "") {
            console2.log(">>> SAFE: Execute succeeded after nilify - DoS prevented");
            console2.log(">>> Nilify acts as recovery mechanism for gaps");
        } catch Error(string memory reason) {
            console2.log(">>> VULNERABILITY: Execute still fails after nilify:", reason);
            console2.log(">>> Path is permanently DoS'd");
            fail("DoS vulnerability: nilify does not unblock gaps");
        }
    }

    // ========== EXPLOIT ATTEMPT 03: Grace Period Weak Library Bypass ==========

    /// @notice Attempt to verify message with weaker library during grace period
    /// @dev EXPECTED: Should SUCCEED - this is intentional design for library transitions
    /// @dev NOT A VULNERABILITY: OApp owner chooses both libraries
    function test_Exploit03_GracePeriodWeakLibraryBypass() public {
        console2.log("\n=== EXPLOIT ATTEMPT 03: Grace Period Weak Library Bypass ===");

        MockOApp bobOApp = new MockOApp(address(endpoint));

        // Step 1: Bob sets strict library as primary
        address strictLib = receiveLib;
        address weakLib = maliciousReceiveLib;

        vm.startPrank(bob);
        endpoint.setDelegate(address(bobOApp));
        endpoint.setReceiveLibrary(address(bobOApp), REMOTE_EID, strictLib, 0);
        vm.stopPrank();

        console2.log("Primary library set to strictLib");

        // Step 2: Bob upgrades to new library but sets grace period
        vm.prank(bob);
        endpoint.setReceiveLibrary(address(bobOApp), REMOTE_EID, strictLib, 1000); // 1000 blocks grace

        // Check timeout config
        (address timeoutLib, uint256 expiry) = endpoint.receiveLibraryTimeout(address(bobOApp), REMOTE_EID);
        console2.log("Grace period lib:", timeoutLib);
        console2.log("Grace period expiry:", expiry);

        // Step 3: During grace period, check if old library can still verify
        Origin memory origin = Origin({ srcEid: REMOTE_EID, sender: aliceB32, nonce: 1 });

        bool weakLibValid = endpoint.isValidReceiveLibrary(address(bobOApp), REMOTE_EID, weakLib);
        bool strictLibValid = endpoint.isValidReceiveLibrary(address(bobOApp), REMOTE_EID, strictLib);

        console2.log("Weak lib valid during grace?", weakLibValid);
        console2.log("Strict lib valid?", strictLibValid);

        if (weakLibValid) {
            vm.prank(weakLib);
            endpoint.verify(origin, address(bobOApp), payloadHash1);
            console2.log(">>> DESIGN CHOICE: Grace period allows old library to verify");
            console2.log(">>> This is NOT a vulnerability - OApp owner controls both libraries");
        } else {
            console2.log(">>> Grace period does not accept old library");
        }

        // Step 4: After grace period expires, check again
        vm.roll(block.number + 1001);

        weakLibValid = endpoint.isValidReceiveLibrary(address(bobOApp), REMOTE_EID, weakLib);
        console2.log("Weak lib valid after grace expiry?", weakLibValid);

        if (weakLibValid) {
            fail("VULNERABILITY: Old library still valid after grace period expired");
        } else {
            console2.log(">>> SAFE: Old library rejected after grace period");
        }
    }

    // ========== EXPLOIT ATTEMPT 04: Unauthorized Compose Execution ==========

    /// @notice Attempt to execute arbitrary compose message without proper authorization
    /// @dev EXPECTED: Should FAIL - compose queue requires valid sendCompose first
    function test_Exploit04_UnauthorizedComposeExecution() public {
        console2.log("\n=== EXPLOIT ATTEMPT 04: Unauthorized Compose Execution ===");

        MockOApp bobOApp = new MockOApp(address(endpoint));
        address composerTarget = address(new MockComposer());

        bytes32 fakeGuid = keccak256("fake");
        bytes memory composeMsg = "malicious compose";
        uint16 index = 0;

        // Attempt 1: Direct lzCompose call without sendCompose
        console2.log("Attempt 1: Call lzCompose directly without prior sendCompose");

        vm.prank(attacker);
        try endpoint.lzCompose(
            address(bobOApp),
            composerTarget,
            fakeGuid,
            index,
            composeMsg,
            ""
        ) {
            fail("VULNERABILITY: Unauthorized compose executed");
        } catch Error(string memory) {
            console2.log(">>> SAFE: Direct lzCompose reverted (hash mismatch)");
        } catch (bytes memory) {
            console2.log(">>> SAFE: Direct lzCompose reverted");
        }

        // Attempt 2: Try to call sendCompose as attacker
        console2.log("Attempt 2: Call sendCompose as non-OApp");

        vm.prank(attacker);
        try endpoint.sendCompose(composerTarget, fakeGuid, index, composeMsg) {
            // If sendCompose succeeds, it queues under msg.sender (attacker)
            // Now try to execute
            bytes32 queuedHash = endpoint.composeQueue(attacker, composerTarget, fakeGuid, index);
            console2.log("Compose queued under attacker address");
            console2.logBytes32(queuedHash);

            // Execute the queued compose
            vm.prank(attacker);
            endpoint.lzCompose(attacker, composerTarget, fakeGuid, index, composeMsg, "");

            console2.log(">>> DESIGN ISSUE: Attacker can queue and execute compose to arbitrary target");
            console2.log(">>> BUT: Composer contract should validate msg.sender in lzCompose callback");
            console2.log(">>> NOT A PROTOCOL BUG - Application-layer responsibility");
        } catch (bytes memory) {
            console2.log(">>> SAFE: Compose flow prevented");
        }
    }

    // ========== EXPLOIT ATTEMPT 05: GUID Collision Attack ==========

    /// @notice Attempt to create two different messages with same GUID
    /// @dev EXPECTED: Cryptographically infeasible - requires keccak256 collision
    function test_Exploit05_GUIDCollision() public {
        console2.log("\n=== EXPLOIT ATTEMPT 05: GUID Collision ===");

        // Generate GUIDs with different parameters
        bytes32 guid_a = GUID.generate(1, REMOTE_EID, alice, LOCAL_EID, bobB32);
        bytes32 guid_b = GUID.generate(1, REMOTE_EID, alice, LOCAL_EID, bobB32);

        console2.log("GUID with same params:");
        console2.logBytes32(guid_a);
        console2.logBytes32(guid_b);
        assertEq(guid_a, guid_b, "Same params should produce same GUID");

        // Try different nonce
        bytes32 guid_c = GUID.generate(2, REMOTE_EID, alice, LOCAL_EID, bobB32);
        console2.log("GUID with different nonce:");
        console2.logBytes32(guid_c);
        assertTrue(guid_a != guid_c, "Different nonce should produce different GUID");

        // Try different sender
        bytes32 guid_d = GUID.generate(1, REMOTE_EID, bob, LOCAL_EID, bobB32);
        console2.log("GUID with different sender:");
        console2.logBytes32(guid_d);
        assertTrue(guid_a != guid_d, "Different sender should produce different GUID");

        console2.log(">>> SAFE: GUID collision requires breaking keccak256");
        console2.log(">>> Nonce increments ensure unique GUIDs per path");
    }

    // ========== EXPLOIT ATTEMPT 06: Double Execution via Payload Replay ==========

    /// @notice Attempt to execute same message twice
    /// @dev EXPECTED: Should FAIL - _clearPayload deletes hash, blocking re-execution
    function test_Exploit06_DoubleExecutionReplay() public {
        console2.log("\n=== EXPLOIT ATTEMPT 06: Double Execution via Replay ===");

        MockOApp bobOApp = new MockOApp(address(endpoint));
        vm.prank(bob);
        endpoint.setDelegate(address(bobOApp));

        Origin memory origin = Origin({ srcEid: REMOTE_EID, sender: aliceB32, nonce: 1 });

        // Step 1: Verify and execute once
        vm.prank(receiveLib);
        endpoint.verify(origin, address(bobOApp), payloadHash1);

        vm.prank(attacker);
        endpoint.lzReceive(origin, address(bobOApp), guid1, message1, "");
        console2.log("First execution succeeded");

        uint256 execCountAfterFirst = bobOApp.execCount();
        console2.log("Execution count:", execCountAfterFirst);

        // Step 2: Attempt to execute again with same payload
        vm.prank(attacker);
        try endpoint.lzReceive(origin, address(bobOApp), guid1, message1, "") {
            uint256 execCountAfterSecond = bobOApp.execCount();
            console2.log("Second execution succeeded - count:", execCountAfterSecond);
            fail("VULNERABILITY: Message executed twice");
        } catch Error(string memory reason) {
            console2.log(">>> SAFE: Second execution reverted:", reason);
        } catch (bytes memory) {
            console2.log(">>> SAFE: Second execution reverted");
        }

        // Verify hash was deleted
        bytes32 hashAfterExec = endpoint.inboundPayloadHash(address(bobOApp), REMOTE_EID, aliceB32, 1);
        console2.log("Hash after execution:");
        console2.logBytes32(hashAfterExec);
        assertEq(hashAfterExec, endpoint.EMPTY_PAYLOAD_HASH(), "Hash should be cleared");
    }

    // ========== EXPLOIT ATTEMPT 07: Skip Nonce Authorization Bypass ==========

    /// @notice Attempt to skip nonces without authorization
    /// @dev EXPECTED: Should FAIL - requires _assertAuthorized()
    function test_Exploit07_UnauthorizedNonceSkip() public {
        console2.log("\n=== EXPLOIT ATTEMPT 07: Unauthorized Nonce Skip ===");

        MockOApp bobOApp = new MockOApp(address(endpoint));

        // Attacker tries to skip nonce 1 for Bob's OApp
        vm.prank(attacker);
        try endpoint.skip(address(bobOApp), REMOTE_EID, aliceB32, 1) {
            fail("VULNERABILITY: Attacker skipped nonce without authorization");
        } catch Error(string memory reason) {
            console2.log(">>> SAFE: Skip reverted:", reason);
            assertTrue(bytes(reason).length > 0);
        } catch (bytes memory lowLevelData) {
            // Decode the error
            if (lowLevelData.length >= 4) {
                bytes4 selector = bytes4(lowLevelData);
                console2.log(">>> SAFE: Skip reverted with selector:");
                console2.logBytes4(selector);
                assertEq(selector, Errors.LZ_Unauthorized.selector, "Should revert with LZ_Unauthorized");
            }
        }
    }

    // ========== EXPLOIT ATTEMPT 08: Executor msg.value Underfunding ==========

    /// @notice Attempt to execute lzReceive with less msg.value than OApp expects
    /// @dev EXPECTED: Executor can provide any msg.value - OApp must validate
    /// @dev NOT A PROTOCOL BUG: OApps should encode expected value in message
    function test_Exploit08_ExecutorValueUnderfunding() public {
        console2.log("\n=== EXPLOIT ATTEMPT 08: Executor msg.value Underfunding ===");

        // Deploy OApp that naively trusts msg.value
        VulnerableValueOApp vulnOApp = new VulnerableValueOApp(address(endpoint));
        vm.prank(address(vulnOApp));
        endpoint.setDelegate(address(vulnOApp));

        Origin memory origin = Origin({ srcEid: REMOTE_EID, sender: aliceB32, nonce: 1 });

        // Verify message
        vm.prank(receiveLib);
        endpoint.verify(origin, address(vulnOApp), payloadHash1);

        // Executor executes with 1 ether msg.value
        vm.deal(attacker, 10 ether);
        vm.prank(attacker);
        endpoint.lzReceive{value: 1 ether}(origin, address(vulnOApp), guid1, message1, "");

        uint256 creditedValue = vulnOApp.creditedValue();
        console2.log("Value credited to user:", creditedValue);

        if (creditedValue == 1 ether) {
            console2.log(">>> APPLICATION BUG: OApp credited whatever executor sent");
            console2.log(">>> NOT A PROTOCOL VULNERABILITY: OApp should encode expected value in message");
            console2.log(">>> Proper fix: OApp validates msg.value against encoded amount");
        }

        // Show proper pattern
        console2.log(">>> SAFE PATTERN: OApp should:");
        console2.log("    1. Encode expected value in message");
        console2.log("    2. Decode and validate msg.value == expectedValue");
        console2.log("    3. Revert if mismatch");
    }

    // ========== EXPLOIT ATTEMPT 09: Burn to Permanently Block Path ==========

    /// @notice Attempt to use burn() to permanently DoS a messaging path
    /// @dev EXPECTED: Burn only works on executed messages (nonce <= lazyInboundNonce)
    function test_Exploit09_BurnDoSAttempt() public {
        console2.log("\n=== EXPLOIT ATTEMPT 09: Burn to Block Path ===");

        MockOApp bobOApp = new MockOApp(address(endpoint));
        vm.prank(bob);
        endpoint.setDelegate(address(bobOApp));

        Origin memory origin = Origin({ srcEid: REMOTE_EID, sender: aliceB32, nonce: 1 });

        // Verify nonce 1
        vm.prank(receiveLib);
        endpoint.verify(origin, address(bobOApp), payloadHash1);

        // Execute nonce 1
        vm.prank(attacker);
        endpoint.lzReceive(origin, address(bobOApp), guid1, message1, "");

        console2.log("Nonce 1 executed, lazyInboundNonce =", endpoint.lazyInboundNonce(address(bobOApp), REMOTE_EID, aliceB32));

        // Verify nonce 2
        Origin memory origin2 = Origin({ srcEid: REMOTE_EID, sender: aliceB32, nonce: 2 });
        bytes32 guid2Local = GUID.generate(2, REMOTE_EID, alice, LOCAL_EID, bobB32);
        bytes memory payload2Local = abi.encodePacked(guid2Local, message1);
        bytes32 payloadHash2Local = keccak256(payload2Local);

        vm.prank(receiveLib);
        endpoint.verify(origin2, address(bobOApp), payloadHash2Local);

        // Attacker tries to burn future nonce 2 (should fail - nonce > lazyInboundNonce)
        vm.prank(address(bobOApp));
        try endpoint.burn(address(bobOApp), REMOTE_EID, aliceB32, 2, payloadHash2Local) {
            console2.log(">>> Burn succeeded on future nonce");

            // Try to execute nonce 2
            vm.prank(attacker);
            try endpoint.lzReceive(origin2, address(bobOApp), guid2Local, message1, "") {
                fail("VULNERABILITY: Executed after burn");
            } catch {
                console2.log(">>> Execution blocked after burn - potential DoS");
            }
        } catch Error(string memory reason) {
            console2.log(">>> SAFE: Burn reverted on future nonce:", reason);
        } catch (bytes memory) {
            console2.log(">>> SAFE: Burn reverted on future nonce");
        }
    }

    // ========== EXPLOIT ATTEMPT 10: Library Impersonation ==========

    /// @notice Attempt to call verify() as unregistered library
    /// @dev EXPECTED: Should FAIL - isValidReceiveLibrary checks registration
    function test_Exploit10_LibraryImpersonation() public {
        console2.log("\n=== EXPLOIT ATTEMPT 10: Library Impersonation ===");

        MockOApp bobOApp = new MockOApp(address(endpoint));
        vm.prank(bob);
        endpoint.setDelegate(address(bobOApp));

        Origin memory origin = Origin({ srcEid: REMOTE_EID, sender: aliceB32, nonce: 1 });

        // Attacker tries to verify as unregistered library
        vm.prank(attacker);
        try endpoint.verify(origin, address(bobOApp), payloadHash1) {
            fail("VULNERABILITY: Unregistered address can verify");
        } catch Error(string memory reason) {
            console2.log(">>> SAFE: Verify reverted:", reason);
        } catch (bytes memory lowLevelData) {
            if (lowLevelData.length >= 4) {
                bytes4 selector = bytes4(lowLevelData);
                console2.log(">>> SAFE: Verify reverted with selector:");
                console2.logBytes4(selector);
                assertEq(selector, Errors.LZ_InvalidReceiveLibrary.selector);
            }
        }
    }
}

// ========== MOCK CONTRACTS ==========

contract MockOApp is ILayerZeroReceiver {
    address public endpoint;
    uint256 public execCount;
    bytes public lastMessage;

    constructor(address _endpoint) {
        endpoint = _endpoint;
    }

    function allowInitializePath(Origin calldata) external pure returns (bool) {
        return true;
    }

    function lzReceive(
        Origin calldata,
        bytes32,
        bytes calldata _message,
        address,
        bytes calldata
    ) external payable {
        require(msg.sender == endpoint, "only endpoint");
        execCount++;
        lastMessage = _message;
    }
}

contract MockComposer {
    function lzCompose(
        address _from,
        bytes32,
        bytes calldata,
        address,
        bytes calldata
    ) external payable {
        // Should validate _from is trusted
        // Vulnerability if missing check
    }
}

contract VulnerableValueOApp is ILayerZeroReceiver {
    address public endpoint;
    uint256 public creditedValue;

    constructor(address _endpoint) {
        endpoint = _endpoint;
    }

    function allowInitializePath(Origin calldata) external pure returns (bool) {
        return true;
    }

    function lzReceive(
        Origin calldata,
        bytes32,
        bytes calldata,
        address,
        bytes calldata
    ) external payable {
        require(msg.sender == endpoint, "only endpoint");
        // VULNERABLE: Trusts msg.value without validating against encoded amount
        creditedValue = msg.value;
    }
}

contract MockReceiveLib is IMessageLib {
    address public endpoint;
    uint32 public localEid;

    constructor(address _endpoint, uint32 _localEid) {
        endpoint = _endpoint;
        localEid = _localEid;
    }

    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {
        return interfaceId == type(IMessageLib).interfaceId;
    }

    function setConfig(address, SetConfigParam[] calldata) external {}

    function getConfig(uint32, address, uint32) external pure returns (bytes memory) {
        return "";
    }

    function isSupportedEid(uint32) external pure returns (bool) {
        return true;
    }

    function messageLibType() external pure returns (MessageLibType) {
        return MessageLibType.Receive;
    }

    function version() external pure returns (uint64 major, uint8 minor, uint8 endpointVersion) {
        return (1, 0, 2);
    }
}
