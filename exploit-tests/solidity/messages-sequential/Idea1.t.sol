// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {Test, console2} from "forge-std/Test.sol";
import {MessagingChannel} from "packages/layerzero-v2/evm/protocol/contracts/MessagingChannel.sol";
import {Errors} from "packages/layerzero-v2/evm/protocol/contracts/libs/Errors.sol";

/// @title Exploit test for Sequential Clearing
/// @invariant File:packages/layerzero-v2/evm/protocol/contracts/MessagingChannel.sol:36 - "messages can only be cleared in order to preserve censorship-resistance"
/// @bounty_estimate $2500000
/// @attacker Malicious executor with message queue access
/// @impact Allows skipping messages and clearing later ones out of order
contract Exploit_SequentialClearing is Test, MessagingChannel {
    constructor() MessagingChannel(1) {}

    function _assertAuthorized(address) internal view override {}

    function testExploit_messages_sequential_Idea1() public {
        address receiver = address(0xBEEF);
        uint32 srcEid = 1;
        bytes32 sender = bytes32(uint256(uint160(address(0xCAFE))));
        bytes memory payload = "msg";
        bytes32 hash = keccak256(payload);
        // inbound message 2 without message 1
        _inbound(receiver, srcEid, sender, 2, hash);
        // attempt to clear nonce 2 directly should revert
        vm.expectRevert(abi.encodeWithSelector(Errors.LZ_InvalidNonce.selector, uint64(1)));
        _clearPayload(receiver, srcEid, sender, 2, payload);
    }
}
